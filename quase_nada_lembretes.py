import asyncioimport osfrom dotenv import load_dotenvimport loggingfrom telegram import Updatefrom telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, JobQueue, ApplicationBuilderimport reimport google.generativeai as genai# Carrega as variáveis de ambiente do arquivo .envload_dotenv()TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")GEMINI_API_KEY = os.getenv("GOOGLE_API_KEY")genai.configure(api_key=GEMINI_API_KEY)# Configura o log para ver o que está acontecendologging.basicConfig(    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',    level=logging.INFO)logger = logging.getLogger(__name__)GEMINI_MODEL_NAME = "gemini-2.0-flash-lite"# Inicia o modelo Geminigemini_model = genai.GenerativeModel(GEMINI_MODEL_NAME)# --- Funções do Bot ---# Função que responde ao comando /startasync def start(update: Update, context):    """Envia uma mensagem quando o comando /start é emitido."""    user = update.effective_user    await update.message.reply_html(        f"Olá, {user.mention_html()}! Eu sou seu bot de lembretes. Como posso ajudar?",)# Função que ecoa qualquer mensagem de texto que o usuário enviarasync def echo(update: Update, context):    """Ecoa a mensagem do usuário."""    await update.message.reply_text(f"Você disse: {update.message.text}")# Função para lidar com errosasync def error(update: Update, context):    """Registra Erros causados por Updates."""    logger.warning(f'Update "{update}" causou erro "{context.error}"')    if update.effective_message:        await update.effective_message.reply_text("Ops! Algo deu errado. Por favor, tente novamente mais tarde.")async def obter_resposta_gemini(prompt: str) -> str:    """Envia um prompt para o modelo Gemini e retorna a resposta de texto."""    try:        # Cria uma nova sessão de chat com o modelo Gemini        # Para conversas mais longas, você precisaria manter o estado do chat (histórico)        # Mas para respostas simples, podemos iniciar um chat novo a cada requisição.        chat_session = gemini_model.start_chat(history=[])        response = await chat_session.send_message_async(prompt)        # Retorna a parte de texto da resposta.        # Pode ser necessário adicionar tratamento para respostas que não são de texto.        return response.text    except Exception as e:        logger.error(f"Erro ao interagir com a Gemini API: {e}", exc_info=True)        return "Desculpe, não consegui processar sua solicitação no momento. Minha IA está com problemas."# Handler para lidar com mensagens que não foram capturadas por outros handlers (conversa geral)async def handle_outras_mensagens(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:    """    Lida com mensagens de texto que não são comandos e não são padrões de lembrete.    Envia a mensagem para a Gemini API e responde ao usuário.    """    user_message = update.message.text  # Pega o texto que o usuário digitou    # Envia a mensagem do usuário para a IA Gemini    ai_response = await obter_resposta_gemini(user_message)    # Envia a resposta da IA de volta para o usuário no Telegram    await update.message.reply_text(ai_response)async def disparar_alarme(context: ContextTypes.DEFAULT_TYPE) -> None:    """Disparo do alarme"""    job = context.job    await context.bot.send_message(job.chat_id, text=f"Opa! O seu lembrete de {int(job.data)} segundos acabou!")async def agendar_lembrete(update: Update,  context: ContextTypes.DEFAULT_TYPE) -> None:    try:        # args[0] irá conter o tempo em segundos de quanto tempo de        chat_id = update.effective_message.chat_id        tempo = float(context.match.group(1))        if tempo < 0:            await update.effective_message.reply_text("Desculpe, não podemos viajar para o passado ou agendar tempo negativo!")            return        context.job_queue.run_once(disparar_alarme, tempo, chat_id=chat_id, name=str(chat_id), data=tempo)        text = f"Lembrete para daqui {int(tempo)} agendado com sucesso"        await update.effective_message.reply_text(text)    except (IndexError, ValueError):        await update.effective_message.reply_text("Use números para agendar algo!")# --- Função Principal para Iniciar o Bot ---async def post_init(app):    app.job_queue.set_application(app)    await app.job_queue.start()def main():    """Inicia o bot."""    mensagem_especifica = r"(?i)^vasco$"    lembrete_regex = r"(?i)^agendar lembrete para daqui (\d+(?:\.\d+)?)\s*segundos$"    # Cria a Aplicação e passa o token do seu bot    application = ApplicationBuilder().token(TELEGRAM_TOKEN).post_init(post_init).build()    # Adiciona os Handlers para os comandos e mensagens    application.add_handler(MessageHandler(filters.TEXT & filters.Regex(lembrete_regex), agendar_lembrete))    #Quando a mensagem enviada for correspondente da variável "mensagem_especifica" ele roda a def "start"    application.add_handler(MessageHandler(filters.TEXT & filters.Regex(mensagem_especifica), start))    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_outras_mensagens))    # Adiciona o Handler para erros    application.add_error_handler(error)    # Inicia o bot (polling)    application.run_polling(allowed_updates=Update.ALL_TYPES)if __name__ == "__main__":    main()