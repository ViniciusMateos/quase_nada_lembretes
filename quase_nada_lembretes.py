import asyncioimport osfrom number_parser import parse_ordinal, parse_numberfrom dotenv import load_dotenvimport loggingfrom telegram import Updatefrom pytz import timezone as pytz_timezone  # Mais confi√°vel para fusos hor√°riosfrom telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, JobQueue, ApplicationBuilderimport reimport google.generativeai as genai# import whisperimport jsonimport tempfilefrom datetime import datetime, timedelta, timezonefrom keep_alive import keep_alivekeep_alive()  # isso inicia o servidor web fake# Carrega as vari√°veis de ambiente do arquivo .envload_dotenv()TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")GEMINI_API_KEY = os.getenv("GOOGLE_API_KEY")genai.configure(api_key=GEMINI_API_KEY)# Configura o log para ver o que est√° acontecendologging.basicConfig(    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',    level=logging.INFO)logger = logging.getLogger(__name__)try:    # model_whisper = whisper.load_model("medium")    logger.info("Modelo Whisper 'medium' carregado com sucesso.")except Exception as e:    model_whisper = None    logger.error(f"ERRO AO CARREGAR MODELO WHISPER: {e}", exc_info=True)    logger.warning("Funcionalidade de transcri√ß√£o de √°udio pode estar desativada.")modelo_gemini_instancia = None # Inicializa a inst√¢ncia como None por padr√£oif GEMINI_API_KEY:    try:        genai.configure(api_key=GEMINI_API_KEY)        modelo_gemini = "gemini-2.0-flash-lite" # Nome recomendado para flash-lite        modelo_gemini_instancia = genai.GenerativeModel(modelo_gemini)        logger.info(f"Modelo Gemini '{modelo_gemini}' inicializado com sucesso.")    except Exception as e:        logger.error(f"ERRO AO INICIALIZAR MODELO GEMINI: {e}", exc_info=True)        # Se houver erro, modelo_gemini_instancia permanece None, e ser√° tratado nas fun√ß√µeselse:    logger.warning("GEMINI_API_KEY n√£o encontrada no arquivo .env. Funcionalidades da IA desativadas.")# --- Fun√ß√µes do Bot ---# Fun√ß√£o que responde ao comando /startasync def start(update: Update, context):    """Envia uma mensagem quando o comando /start √© emitido."""    user = update.effective_user    await update.message.reply_html(        f"Ol√°, {user.mention_html()}! Eu sou seu bot de lembretes. Como posso ajudar?",)# Fun√ß√£o para processar mensagem de voz e transcreverasync def transcrever_voz(update: Update, context: ContextTypes.DEFAULT_TYPE):    if update.message.voice:        voice = update.message.voice        with tempfile.NamedTemporaryFile(suffix=".ogg") as temp_audio:            voice_file = await voice.get_file()            await voice_file.download_to_drive(custom_path=temp_audio.name)            loop = asyncio.get_event_loop()            result = await loop.run_in_executor(None, model_whisper.transcribe, temp_audio.name)            texto_transcrito = result.get("text", "").strip()            return texto_transcrito# Handler para mensagem de voz que transcreve e repassa para a fun√ß√£o de textoasync def lidar_com_mensagem_de_voz(update: Update, context: ContextTypes.DEFAULT_TYPE):    if not update.message.voice:        await update.message.reply_text("Por favor, envie uma mensagem de voz para transcrever.")        return    await update.message.reply_text("üîç Transcrevendo √°udio...")    try:        # Cria um arquivo tempor√°rio com um nome √∫nico e fecha-o imediatamente        with tempfile.NamedTemporaryFile(suffix=".ogg", delete=False) as temp_audio:            temp_path = temp_audio.name        try:            # Baixa o √°udio para o arquivo            voice_file = await update.message.voice.get_file()            await voice_file.download_to_drive(custom_path=temp_path)            # Transcreve usando Whisper            loop = asyncio.get_event_loop()            result = await loop.run_in_executor(None, model_whisper.transcribe, temp_path)            texto_transcrito = result.get("text", "").strip()            if not texto_transcrito:                await update.message.reply_text("N√£o consegui transcrever o √°udio. Pode tentar novamente?")                return            await update.message.reply_text(f"üé§ Transcri√ß√£o: {texto_transcrito}")            await lidar_com_mensagens_texto_geral(update, context, texto_transcrito=texto_transcrito)        finally:            # Garante que o arquivo tempor√°rio ser√° removido            try:                os.unlink(temp_path)            except:                pass    except Exception as e:        logger.error(f"Erro ao transcrever √°udio: {e}", exc_info=True)        await update.message.reply_text("Ocorreu um erro ao processar o √°udio. Tente novamente mais tarde.")# Fun√ß√£o para lidar com errosasync def lidar_erros(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:    if update and hasattr(update, "effective_message") and update.effective_message:        await update.effective_message.reply_text("Ocorreu um erro inesperado.")        print("Erro fora de contexto de mensagem (provavelmente em um job):", context.error)    else:        print("Erro fora de contexto de mensagem (provavelmente em um job):", context.error)def substituir_numeros_por_extenso(texto: str) -> str:    palavras = texto.split()    resultado = []    for palavra in palavras:        try:            numero = parse_number(palavra)            if numero is not None:                resultado.append(str(numero))            else:                resultado.append(palavra)        except Exception:            resultado.append(palavra)    return ' '.join(resultado)async def obter_resposta_gemini(prompt: str) -> str:    """Envia um prompt para o modelo Gemini e retorna a resposta de texto."""    try:        # Cria uma nova sess√£o de chat com o modelo Gemini        # Para conversas mais longas, voc√™ precisaria manter o estado do chat (hist√≥rico)        # Mas para respostas simples, podemos iniciar um chat novo a cada requisi√ß√£o.        chat_session = modelo_gemini_instancia.start_chat(history=[])        response = await chat_session.send_message_async(prompt)        # Retorna a parte de texto da resposta.        # Pode ser necess√°rio adicionar tratamento para respostas que n√£o s√£o de texto.        return response.text    except Exception as e:        logger.error(f"Erro ao interagir com a Gemini API: {e}", exc_info=True)        return "Desculpe, n√£o consegui processar sua solicita√ß√£o no momento. Minha IA est√° com problemas."def intervalo_recorrencia_em_segundos(recorrencia: str | None) -> int | None:    if not recorrencia:        return None    r = recorrencia.lower()    # Exemplo: "de 2 em 2 minutos" ou "a cada 2 minutos"    match_minutos = re.search(r"(?:de|a cada)\s*(\d+)\s*minutos?", r)    if match_minutos:        return int(match_minutos.group(1)) * 60    # "di√°rio" ou "diaria"    if "di√°rio" in r or "diaria" in r:        return 24 * 3600    # "semanal"    if "semanal" in r:        return 7 * 24 * 3600    # "mensal"    if "mensal" in r:        return 30 * 24 * 3600    # Se quiser, pode tentar identificar "toda ter√ßa", "toda segunda" etc e tratar depois    return Noneasync def extrair_detalhes_lembrete_com_gemini(texto_usuario: str) -> dict | None:    """    Usa a Gemini API para extrair detalhes de um lembrete em linguagem natural.    Retorna um dicion√°rio com 'title', 'time', 'date', 'recurrence', 'relative_seconds' ou None se falhar.    """    if not modelo_gemini:        logger.warning("Modelo Gemini n√£o configurado. N√£o √© poss√≠vel extrair detalhes de lembretes inteligentes.")        return None    # Adiciona a data e hora atual ao prompt para "agora" ou "hoje"    momento_atual = datetime.now(timezone.utc)    # Formato do prompt para a IA    prompt_ia = f"""    Extraia as seguintes informa√ß√µes de um pedido de lembrete em portugu√™s.    Formate a sa√≠da como um objeto JSON.    Se uma informa√ß√£o n√£o for encontrada, use null.    Campos esperados:    - "titulo": (string) A a√ß√£o ou o que deve ser lembrado. Ex: "comprar p√£o", "ligar para a Maria".    - "hora": (string, opcional) A hora no formato HH:MM (24 horas). Ex: "08:00", "14:30". Se for "agora" ou "imediatamente", use a hora atual (ex: {momento_atual.strftime('%H:%M')}). Se for "daqui X tempo", calcule a hora futura a partir de agora (ex: daqui 30 minutos √© {(momento_atual + timedelta(minutes=30)).strftime('%H:%M')}).    - "data": (string, opcional) A data no formato AAAA-MM-DD. Ex: "2025-07-21". Se for "hoje", use {momento_atual.strftime('%Y-%m-%d')}. Se for "amanh√£", use {(momento_atual + timedelta(days=1)).strftime('%Y-%m-%d')}. Se for "pr√≥xima segunda", calcule a data da pr√≥xima segunda-feira.    - "recorrencia": (string, opcional) Se o lembrete se repete. Ex: "di√°rio", "semanal", "mensal", "anual", "toda ter√ßa". Se n√£o se repete, null.    - "segundos_relativos": (float, opcional) Se o lembrete √© para "daqui X segundos/minutos/horas", o tempo em segundos. Ex: 300.    Exemplos:    "Me lembre de comprar p√£o amanh√£ √†s 7 da manh√£."    {{ "titulo": "comprar p√£o", "hora": "07:00", "data": "{(momento_atual + timedelta(days=1)).strftime('%Y-%m-%d')}", "recorrencia": null, "segundos_relativos": null }}    "Lembre-me de ir √† academia toda ter√ßa-feira √†s 18h."    {{ "titulo": "ir √† academia", "hora": "18:00", "data": null, "recorrencia": "toda ter√ßa-feira", "segundos_relativos": null }}    "Agendar lembrete para daqui 5 segundos para fazer algo."    {{ "titulo": "fazer algo", "hora": null, "data": null, "recorrencia": null, "segundos_relativos": 5.0 }}    "Me lembre em 30 minutos de tirar o bolo do forno."    {{ "titulo": "tirar o bolo do forno", "hora": null, "data": null, "recorrencia": null, "segundos_relativos": 1800.0 }}    "Lembre-me de pagar a conta dia 25."    {{ "titulo": "pagar a conta", "hora": null, "data": "{momento_atual.year}-{momento_atual.month}-25", "recorrencia": null, "segundos_relativos": null }}    "Lembrete para agora: reuni√£o."    {{ "titulo": "reuni√£o", "hora": "{momento_atual.strftime('%H:%M')}", "data": "{momento_atual.strftime('%Y-%m-%d')}", "recorrencia": null, "segundos_relativos": 0.0 }}    Pedido: "{texto_usuario}"    """    try:        # Usa o modelo Gemini para gerar a resposta        sessao_chat = modelo_gemini_instancia.start_chat()        resposta = await sessao_chat.send_message_async(prompt_ia)        # Tenta parsear a resposta como JSON        texto_resposta = resposta.text.strip()        # Remove blocos de c√≥digo markdown se existirem (```json...```)        if texto_resposta.startswith("```json") and texto_resposta.endswith("```"):            texto_resposta = texto_resposta[7:-3].strip()        detalhes = json.loads(texto_resposta)        return detalhes    except json.JSONDecodeError as e:        logger.error(            f"Erro ao decodificar JSON da Gemini API: {e}. Resposta: {resposta.text if 'resposta' in locals() else 'N/A'}",            exc_info=True)        return None    except Exception as e:        logger.error(f"Erro ao interagir com a Gemini API para extrair lembrete: {e}", exc_info=True)        return None# Handler para lidar com mensagens que n√£o foram capturadas por outros handlers (conversa geral)# --- Nova l√≥gica para lidar com mensagens (substituindo agendar_lembrete como handler) ---async def lidar_com_mensagens_texto_geral(update: Update, context: ContextTypes.DEFAULT_TYPE, texto_transcrito: str = None) -> None:    """    Lida com mensagens de texto que n√£o s√£o comandos.    Tenta extrair um lembrete usando a IA; se n√£o conseguir, responde como IA de chat geral.    """    id_chat = update.effective_message.chat_id    mensagem_usuario = texto_transcrito if texto_transcrito else update.effective_message.text    # Pr√©-processa a mensagem substituindo n√∫meros por extenso    mensagem_usuario_processada = substituir_numeros_por_extenso(mensagem_usuario)    if not modelo_gemini_instancia:        await update.effective_message.reply_text(            "Desculpe, a funcionalidade de IA est√° desativada. "            "Por favor, verifique a configura√ß√£o da chave GEMINI_API_KEY."        )        return    await update.effective_message.reply_text("Processando sua solicita√ß√£o com a IA...")    # Tenta extrair os detalhes do lembrete    detalhes_lembrete = await extrair_detalhes_lembrete_com_gemini(mensagem_usuario_processada)    # --- L√≥gica de Agendamento ---    if detalhes_lembrete and (detalhes_lembrete.get("segundos_relativos") is not None or                              detalhes_lembrete.get("hora") is not None or                              detalhes_lembrete.get("data") is not None or                              detalhes_lembrete.get("recorrencia") is not None):        titulo = detalhes_lembrete.get("titulo")        hora_str = detalhes_lembrete.get("hora")        data_str = detalhes_lembrete.get("data")        recorrencia = detalhes_lembrete.get("recorrencia")        segundos_relativos = detalhes_lembrete.get("segundos_relativos")        momento_agendamento = None        if segundos_relativos is not None:            try:                momento_agendamento = datetime.now(timezone.utc) + timedelta(seconds=float(segundos_relativos))            except ValueError:                await update.effective_message.reply_text(                    "Tempo relativo inv√°lido. Por favor, use um n√∫mero para segundos/minutos/horas.")                return        elif hora_str and data_str:            try:                tz_brasilia = pytz_timezone('America/Sao_Paulo')                momento_local = datetime.strptime(f"{data_str} {hora_str}", "%Y-%m-%d %H:%M")                momento_local = tz_brasilia.localize(momento_local)                momento_agendamento = momento_local.astimezone(timezone.utc)            except ValueError:                await update.effective_message.reply_text("Formato de data ou hora inv√°lido. Tente AAAA-MM-DD HH:MM.")                return        elif hora_str:            try:                hora_parseada = datetime.strptime(hora_str, "%H:%M").time()                hoje_utc = datetime.now(timezone.utc).date()                tz_brasilia = pytz_timezone('America/Sao_Paulo')                hoje_brasilia = datetime.now(tz_brasilia).date()                momento_local = datetime.combine(hoje_brasilia, hora_parseada)                momento_local = tz_brasilia.localize(momento_local)                momento_agendamento = momento_local.astimezone(timezone.utc)                # Corrige lembrete para o dia seguinte se hor√°rio j√° passou                if momento_agendamento < datetime.now(timezone.utc):                    momento_agendamento += timedelta(days=1)            except ValueError:                await update.effective_message.reply_text("Formato de hora inv√°lido. Tente HH:MM.")                return        elif data_str:            try:                momento_agendamento = datetime.strptime(data_str, "%Y-%m-%d").replace(tzinfo=timezone.utc)            except ValueError:                await update.effective_message.reply_text("Formato de data inv√°lido. Tente AAAA-MM-DD.")                return        # Valida√ß√£o final do agendamento        if momento_agendamento and momento_agendamento < datetime.now(timezone.utc):            await update.effective_message.reply_text(                "N√£o consigo agendar lembretes no passado. Por favor, forne√ßa uma data/hora futura.")            return        if not titulo:            titulo = "Lembrete Geral"        # --- L√≥gica de Recorr√™ncia ---        intervalo = intervalo_recorrencia_em_segundos(recorrencia)        # AQUI VOC√ä PODE DECIDIR SE QUER SEMPRE REMOVER O ANTERIOR OU S√ì SE FOR RECORRENTE        # Por simplicidade, vamos sempre remover o anterior para o mesmo chat_id para evitar duplica√ß√£o.        if intervalo:            # Agenda lembrete repetitivo            # first: Se momento_agendamento existe e est√° no futuro, usa-o. Sen√£o, usa o intervalo a partir de agora.            first_run_delay = intervalo if not momento_agendamento else (                        momento_agendamento - datetime.now(timezone.utc)).total_seconds()            # Calcula o 'first' como um datetime UTC            if momento_agendamento:                primeira_execucao = momento_agendamento            else:                primeira_execucao = datetime.now(timezone.utc) + timedelta(seconds=intervalo)            context.job_queue.run_repeating(                disparar_alarme,                interval=intervalo,  # Intervalo em segundos                first=primeira_execucao,  # Primeira execu√ß√£o como datetime (UTC)                chat_id=id_chat,                name=str(id_chat),                data=titulo            )            texto_resposta = f"Lembrete '{titulo}' agendado para repetir a cada {recorrencia}."            if momento_agendamento:                texto_resposta += f" A primeira execu√ß√£o ser√° em {primeira_execucao.strftime('%Y-%m-%d %H:%M')}!"            tz_brasilia = pytz_timezone('America/Sao_Paulo')            momento_local = momento_agendamento.astimezone(tz_brasilia)            await update.effective_message.reply_text(                f"‚è∞ Lembrete '{titulo}' agendado para:\n"                f"üìÖ {momento_local.strftime('%d/%m/%Y')}\n"                f"üïí {momento_local.strftime('%H:%M')} (hor√°rio de Bras√≠lia)\n"                f"‚úÖ Agendado com sucesso!"            )        elif momento_agendamento:            # Agenda lembrete √∫nico            context.job_queue.run_once(                disparar_alarme,                when=momento_agendamento,  # Primeira execu√ß√£o como datetime (UTC)                chat_id=id_chat,                name=str(id_chat),                data=titulo            )            tz_brasilia = pytz_timezone('America/Sao_Paulo')            momento_local = momento_agendamento.astimezone(tz_brasilia)            await update.effective_message.reply_text(                f"‚è∞ Lembrete '{titulo}' agendado para:\n"                f"üìÖ {momento_local.strftime('%d/%m/%Y')}\n"                f"üïí {momento_local.strftime('%H:%M')} (hor√°rio de Bras√≠lia)\n"                f"‚úÖ Agendado com sucesso!"            )        else:            # Se a IA extraiu detalhes mas n√£o conseguiu determinar um momento, isso √© um problema.            # Deveria ser pego pelo catch-all de erro da IA de extra√ß√£o.            # Se chegar aqui, significa que detalhes_lembrete n√£o √© None, mas n√£o tem info de tempo.            await update.effective_message.reply_text(                "Desculpe, a IA entendeu sua inten√ß√£o de lembrete, mas n√£o conseguiu determinar um tempo ou data espec√≠ficos para agendar. "                "Por favor, seja mais expl√≠cito (ex: 'hoje √†s 10h', 'daqui 5 minutos', 'todo dia √†s 9h')."            )    else:  # Se detalhes_lembrete √© None ou n√£o cont√©m informa√ß√µes de tempo/t√≠tulo        # === CAIU AQUI: Responde como IA de chat geral ===        resposta_ai = await obter_resposta_gemini(mensagem_usuario)        await update.effective_message.reply_text(resposta_ai)async def disparar_alarme(context: ContextTypes.DEFAULT_TYPE) -> None:    """Disparo do alarme"""    job = context.job    await context.bot.send_message(job.chat_id, text=f"Opa! Lembrete: {job.data}")# --- Fun√ß√£o Principal para Iniciar o Bot ---async def post_init(app):    app.job_queue.set_application(app)    await app.job_queue.start()def main():    """Inicia o bot."""    # Cria a Aplica√ß√£o e passa o token do seu bot    application = ApplicationBuilder().token(TELEGRAM_TOKEN).post_init(post_init).build()    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, lidar_com_mensagens_texto_geral))    application.add_handler(MessageHandler(filters.VOICE, lidar_com_mensagem_de_voz))    # Adiciona o Handler para erros    application.add_error_handler(lidar_erros)    # Inicia o bot (polling)    application.run_polling(allowed_updates=Update.ALL_TYPES)if __name__ == "__main__":    main()